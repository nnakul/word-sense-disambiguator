## About
This project is inspired from the work of *Mihalcea et al.* published in the paper, <a href = "https://www.aclweb.org/anthology/C04-1162.pdf"> *PageRank on Semantic Networks with Application to Word Sense Disambiguation* </a>. The task of word sense disambiguation consists of assigning the most appropriate meaning to a *polysemous* word within a given context. The paper presents an open text word sense disambiguation method that combines the use of logical inferences with *PageRank-style algorithms* applied on graphs extracted from natural language documents. *PageRank* algorithm is a way of measuring the importance of a web page (in a directed graph of web-pages) depending on the number of other pages linked to this page and the number of pages to which this page is linked. This algorithm is extremely extensible and can be used to rank any class of entities arranged in a graph-ic fashion. This intuition behind a *PageRank* algorithm can be used to develop a similar algorithm to measure the importance of a *word sense* in a huge network of senses.

*WORD_SENSE_DISAMBIGUATOR.py* realizes this approach given in the paper. Given a text file, *WORD_SENSE_DISAMBIGUATOR.py* will annotate those words and phrases in the text that have an ambiguous meaning. Following the annotated text, a table would present the most appropriate senses allocated to these ambiguous words/phrases, deduced by the proposed algorithm.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="https://user-images.githubusercontent.com/66432513/120797224-5bedbb80-c559-11eb-8c35-f788074c9bb7.png" width = '900' height = '990'>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="https://user-images.githubusercontent.com/66432513/120797226-5db77f00-c559-11eb-8485-120a963ac75b.png" width = '900' height = '990'>

## Graph Construction
The most important step before implementing a *PageRank*-style algorithm is to translate all the raw data into a graph. The *Text Synset Graph* constructed in this step has *word senses* as its nodes. Every word in the graph that has an ambiguous meaning must be having multiple senses. Even the unambiguous senses must have a unique sense associated with them. Post the *pre-processing* stage, the nodes in the network are identified as the senses of words (and also collocations) in the text. Note that given an ambiguous word, only those senses are chosen as candidates that have the same *part of speech tag* as that word in its context. For example, given the word *tick* in a sentence *"The comforting tick of..."*, the *verb* senses of this word would not be considered as candidates. In the pre-processing stage, *named entities* are identified (names of people, places, books etc.) because these are always unambiguous.

The next important task is introducing edges in the network. *WordNet* is a lexical knowledge base for English that defines words, meanings, and relations between them. The basic unit in WordNet is a *synset*, which is a set of synonym words or word phrases that represents a concept. *Synset* can be rightly considered as a *sense* that might be shared by multiple words in the vocabulary. The nodes in the *Text Synset Graph* are actually the *Synset* objects defined in Python's WordNet module. An undirected edge is introduced between two nodes if and only if the corresponding words/collocations, of which they are a candidate, are present within some context window of each other; and their corresponding synsets share some semantic relationship defined in the WordNet. *Colexical* synsets (the ones having the same root-name attribute) are always isolated from each other. WordNet defines several semantic relations between synsets. The ones used in this project while constructing the graph are -- *Synonymy*, *Hypernymy*, *Hyponymy*, *Meronymy*, *Holonymy*, *Entailment*, *Coordinate* and *Exceptional* (exceptional relationships are not given in the paper but they are used to account for the pairs of synsets that do not share any of the other concrete relationships but show exceptionally high *WuPalmer* similarity, say above 75%).

## Graph Sparseness and Breaking Ties



